<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Clariti Fee Formula Lab (v21)</title>
  <style>
    :root{--bg:#0b0d12;--panel:#121623;--muted:#8d95a7;--text:#e8ecf3;--line:#232a3b;--bad:#ff6b6b;--ok:#2bd576;}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:linear-gradient(180deg,#070910,#0b0d12 30%,#0b0d12);color:var(--text);}
    .wrap{max-width:1100px;margin:24px auto;padding:0 16px 40px;}
    header{display:flex;align-items:flex-end;justify-content:space-between;gap:16px;margin-bottom:16px;}
    h1{font-size:18px;margin:0;}
    .sub{color:var(--muted);font-size:12px;margin-top:6px;line-height:1.5;}
    .grid{display:grid;grid-template-columns:1.15fr .85fr;gap:14px;}
    .card{background:rgba(18,22,35,.92);border:1px solid var(--line);border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.35);overflow:hidden;}
    .card h2{font-size:13px;margin:0;padding:12px 14px;border-bottom:1px solid var(--line);color:#d8deea;}
    .card .body{padding:14px;}
    textarea,input,select,button{font:inherit}
    textarea{width:100%;min-height:240px;resize:vertical;background:#0e1220;border:1px solid var(--line);border-radius:12px;color:var(--text);padding:10px;line-height:1.35;outline:none;}
    textarea:focus,input:focus,select:focus{border-color:#3a4664;box-shadow:0 0 0 3px rgba(66,113,255,.15)}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    button{background:#1b2440;border:1px solid #2a3557;color:var(--text);padding:10px 12px;border-radius:12px;cursor:pointer}
    button:hover{border-color:#3a4664}
    button.primary{background:#2a3a73;border-color:#3b53a8}
    .pill{font-size:11px;color:var(--muted);border:1px solid var(--line);padding:5px 8px;border-radius:999px}
    .inputs{display:flex;flex-direction:column;gap:10px}
    .field{display:grid;grid-template-columns:minmax(0,1fr) 220px;gap:10px;align-items:start}
    .field label{font-size:12px;color:#d9dfea;word-break:break-all;overflow-wrap:anywhere}
    .field .meta{font-size:11px;color:var(--muted);margin-top:3px;word-break:break-all;overflow-wrap:anywhere}
    .field input{width:100%;min-width:0;background:#0e1220;border:1px solid var(--line);border-radius:12px;color:var(--text);padding:9px 10px;outline:none}
    .field input[type="checkbox"]{width:auto}
    .out{white-space:pre-wrap;background:#0e1220;border:1px solid var(--line);border-radius:12px;padding:10px;min-height:90px}
    .ok{color:var(--ok)}
    .bad{color:var(--bad)}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
    .caretLine{color:var(--bad)}
    .small{font-size:12px;color:var(--muted);line-height:1.5}
    .kvs{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .kv{border:1px solid var(--line);border-radius:12px;padding:10px;background:#0e1220}
    .kv .k{font-size:11px;color:var(--muted)}
    .kv .v{font-size:13px;margin-top:6px}
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <div>
      <h1>Clariti Fee Formula Lab</h1>
      <div class="sub">
        Version v21 — PEG/packrat parsing with AST spans, function signatures, structured aggregates (incl. WHERE), and deterministic error pinpointing.
      </div>
    </div>
    <div class="row">
      <span class="pill mono" id="parseStatus">Idle</span>
      <button id="btnLoad">Load sample</button>
      <button id="btnAnalyze">Analyze</button>
      <button class="primary" id="btnCalc">Calculate</button>
    </div>
  
  </header>

  <section class="card" id="supportedSection" style="margin-bottom:14px;">
    <h2>Supported functions</h2>
    <div class="body">
      <div class="out mono" id="supportedFns" style="min-height:44px"></div>
      <div class="small" style="margin-top:10px;">Notes: string literals use <span class="mono">"double quotes"</span> for hardcoded comparisons, and <span class="mono">'single quotes'</span> inside aggregate <span class="mono">WHERE</span> filters.</div>
    </div>
  </section>


  <div class="grid">
    <section class="card">
      <h2>Formula</h2>
      <div class="body">
        <textarea id="formula" spellcheck="false" class="mono" placeholder="Enter Clariti fee formula (e.g., MULT(0.1, SUM(Object.Field WHERE Field = '0')))..."></textarea>
        <div style="height:10px"></div>
        <div class="kvs">
          <div class="kv">
            <div class="k">Parse / Validation</div>
            <div class="v mono" id="diagStatus">—</div>
          </div>
          <div class="kv">
            <div class="k">Detected Inputs</div>
            <div class="v mono" id="inputsCount">—</div>
          </div>
        </div>
        <div style="height:10px"></div>
        <div class="small">Diagnostics (with location):</div>
        <div class="out mono" id="diagnostics"></div>
      </div>
    </section>

    <section class="card">
      <h2>Inputs & Output</h2>
      <div class="body">
        <div class="inputs" id="inputs"></div>
        <div style="height:10px"></div>
        <div class="row">
          <span class="pill">Rules enforced: arity + types + negative fee disallowed</span>
        </div>
        <div style="height:10px"></div>
        <div class="small">Output:</div>
        <div class="out mono" id="output"></div>
        <div style="height:10px"></div>
        <button id="btnSelfTest">Run self-tests</button>
        <div class="out mono" id="selftests" style="margin-top:10px;min-height:70px"></div>
      
        <div style="height:10px"></div>
        <div class="out mono" id="fnlist" style="min-height:90px"></div>
</div>
    </section>
  </div>
</div>

<script>
/* ============================
   Packrat PEG-style parser
   ============================ */

function FormulaError(message, span, kind="ERROR") {
  const e = new Error(message);
  e.kind = kind;
  e.span = span || null;
  return e;
}

function computeLineCol(src, index) {
  let line = 1, col = 1;
  for (let i = 0; i < index; i++) {
    if (src[i] === '\n') { line++; col = 1; }
    else col++;
  }
  return {line, col};
}

function formatSpan(src, span) {
  if (!span) return "";
  const {line, col} = computeLineCol(src, span.start);
  return ` (line ${line}, col ${col})`;
}

function caretSnippet(src, span) {
  if (!span) return "";
  const start = span.start;
  const {line, col} = computeLineCol(src, start);

  // get that line text
  const lines = src.split('\n');
  const lineText = lines[line-1] ?? "";
  const caretPos = Math.max(1, col);
  const caret = " ".repeat(caretPos-1) + "^";
  return `${lineText}\n${caret}`;
}

class Parser {
  constructor(src) {
    this.src = src;
    this.len = src.length;
    this.memo = new Map(); // key: rule@pos -> {node,pos} or {fail:true, expected:Set}
  }

  key(rule, pos) { return rule + "@" + pos; }

  parse() {
    const r = this.Expression(0);
    const pos = r.pos;
    const pos2 = this.ws(pos);
    if (!r.ok) throw this.makeParseError(0, r.expected);
    if (pos2 !== this.len) {
      throw FormulaError(`Unexpected token '${this.src[pos2]}'`, {start:pos2,end:pos2+1}, "SYNTAX");
    }
    return r.node;
  }

  ws(pos) {
    while (pos < this.len) {
      const ch = this.src[pos];
      if (ch === ' ' || ch === '\t' || ch === '\n' || ch === '\r') pos++;
      else break;
    }
    return pos;
  }

  mergeExpected(a, b) {
    const out = new Set(a || []);
    for (const x of (b || [])) out.add(x);
    return out;
  }

  fail(pos, expected) { return {ok:false,pos,expected: new Set(expected||[])}; }

  ok(node, pos) { return {ok:true,node,pos}; }

  Expression(pos) {
    pos = this.ws(pos);
    // Ordered choice: FunctionCall / MergeField / Null / Number / String
    let bestFail = null;

    for (const rule of [this.FunctionCall.bind(this),
                       this.MergeField.bind(this),
                       this.NullLiteral.bind(this),
                       this.NumberLiteral.bind(this),
                       this.StringLiteral.bind(this)]) {
      const r = rule(pos);
      if (r.ok) return r;
      bestFail = bestFail ? this.pickBestFail(bestFail, r) : r;
    }
    return bestFail || this.fail(pos, ["expression"]);
  }

  pickBestFail(a, b) {
    // Choose the one that got farther; if tie, union expected
    if (!a) return b;
    if (!b) return a;
    if (b.pos > a.pos) return b;
    if (a.pos > b.pos) return a;
    return this.fail(a.pos, this.mergeExpected(a.expected, b.expected));
  }

  Identifier(pos) {
    pos = this.ws(pos);
    const start = pos;
    if (pos >= this.len) return this.fail(pos, ["identifier"]);
    const isAlpha = c => /[A-Za-z_]/.test(c);
    const isAlnum = c => /[A-Za-z0-9_]/.test(c);
    if (!isAlpha(this.src[pos])) return this.fail(pos, ["identifier"]);
    pos++;
    while (pos < this.len && isAlnum(this.src[pos])) pos++;
    const name = this.src.slice(start, pos);
    return this.ok({type:"Identifier", name, span:{start, end:pos}}, pos);
  }

  IdentifierPath(pos) {
    // identifiers separated by dots, e.g., MUSW__Fee__c.MUSW__Amount__c or rel__r.Field__c
    pos = this.ws(pos);
    const start = pos;
    let parts = [];
    let r = this.Identifier(pos);
    if (!r.ok) return r;
    parts.push(r.node.name);
    pos = r.pos;

    while (true) {
      pos = this.ws(pos);
      if (this.src[pos] !== '.') break;
      pos++;
      const r2 = this.Identifier(pos);
      if (!r2.ok) return this.fail(pos, ["identifier after '.'"]);
      parts.push(r2.node.name);
      pos = r2.pos;
    }
    return this.ok({type:"IdentifierPath", parts, span:{start, end:pos}}, pos);
  }

  StringLiteral(pos) {
    pos = this.ws(pos);
    const start = pos;
    const q = this.src[pos];
    if (q !== "'" && q !== '"') return this.fail(pos, ["string"]);
    pos++;
    let out = "";
    while (pos < this.len) {
      const ch = this.src[pos];
      if (ch === q) { pos++; return this.ok({type:"String", value: out, quote: q, span:{start, end:pos}}, pos); }
      if (ch === '\\') {
        const nxt = this.src[pos+1];
        if (nxt === q || nxt === '\\') { out += nxt; pos += 2; continue; }
      }
      out += ch; pos++;
    }
    return this.fail(pos, [`closing quote ${q}`]);
  }

  NumberLiteral(pos) {
    pos = this.ws(pos);
    const start = pos;
    const s = this.src;
    let i = pos;
    let seen = false;
    if (s[i] === '+' || s[i] === '-') i++;
    while (i < this.len && /[0-9]/.test(s[i])) { i++; seen = true; }
    if (i < this.len && s[i] === '.') {
      i++;
      while (i < this.len && /[0-9]/.test(s[i])) { i++; seen = true; }
    }
    if (!seen) return this.fail(pos, ["number"]);
    const raw = s.slice(pos, i);
    const val = Number(raw);
    if (!Number.isFinite(val)) return this.fail(pos, ["finite number"]);
    return this.ok({type:"Number", value: val, span:{start, end:i}}, i);
  }

  NullLiteral(pos) {
    pos = this.ws(pos);
    const start = pos;
    if (this.src.slice(pos, pos+4).toLowerCase() === "null") {
      return this.ok({type:"Null", value:null, span:{start, end:pos+4}}, pos+4);
    }
    return this.fail(pos, ["null"]);
  }

  MergeField(pos) {
    pos = this.ws(pos);
    const start = pos;
    if (this.src.slice(pos, pos+2) !== "{!") return this.fail(pos, ["merge field"]);
    pos += 2;
    const r = this.IdentifierPath(pos);
    if (!r.ok) return this.fail(r.pos, ["merge field path"]);
    pos = r.pos;
    pos = this.ws(pos);
    if (this.src[pos] !== "}") return this.fail(pos, ["}"]);
    pos++;
    const path = r.node.parts.join(".");
    return this.ok({type:"MergeField", path, span:{start, end:pos}}, pos);
  }

  FunctionCall(pos) {
    pos = this.ws(pos);
    const start = pos;
    const rName = this.Identifier(pos);
    if (!rName.ok) return rName;
    const name = rName.node.name;
    pos = this.ws(rName.pos);
    if (this.src[pos] !== "(") return this.fail(pos, ["("]);
    pos++;
    // Hard stop on unsupported functions (do not parse further)
    const fnName = name.toUpperCase();
    if (!FUNCTIONS[fnName]) {
      throw FormulaError(`Function ${name} is unsupported`, {start, end: start + name.length}, "FUNC");
    }
    let args = [];
    pos = this.ws(pos);
    if (this.src[pos] === ")") {
      pos++;
      return this.ok({type:"Call", name, args, span:{start, end:pos}}, pos);
    }
    while (true) {
      // Special: aggregate arg inside SUM/COUNT/AVG/MIN/MAX
      let rArg;
      if (["SUM","COUNT","AVG","MIN","MAX"].includes(name.toUpperCase())) {
        rArg = this.AggregateExpr(pos);
        // If AggregateExpr fails, fall back to Expression for better error messages
        if (!rArg.ok) rArg = this.Expression(pos);
      } else {
        rArg = this.Expression(pos);
      }
      if (!rArg.ok) return rArg;
      args.push(rArg.node);
      pos = this.ws(rArg.pos);
      if (this.src[pos] === ",") { pos++; pos = this.ws(pos); continue; }
      if (this.src[pos] === ")") { pos++; break; }
      return this.fail(pos, [", or )"]);
    }
    return this.ok({type:"Call", name, args, span:{start, end:pos}}, pos);
  }

  AggregateExpr(pos) {
    // Grammar: <Obj>.<Field> (WHERE <FieldPath> <Op> <Literal>)?
    pos = this.ws(pos);
    const start = pos;
    const rObjField = this.IdentifierPath(pos);
    if (!rObjField.ok) return rObjField;
    const parts = rObjField.node.parts;
    if (parts.length < 2) return this.fail(rObjField.pos, ["Object.Field"]);
    pos = this.ws(rObjField.pos);

    let where = null;
    if (this.src.slice(pos, pos+5).toUpperCase() === "WHERE") {
      pos += 5;
      pos = this.ws(pos);
      const rLeft = this.IdentifierPath(pos);
      if (!rLeft.ok) return rLeft;
      pos = this.ws(rLeft.pos);

      // Operators: binary comparisons OR IN (...)
      const ops = ["!=", ">=", "<=", "=", ">", "<"];
      let op = null;
      let opKind = "binary"; // binary | in
      let opSpan = null;

      // IN keyword (case-insensitive)
      if (this.src.slice(pos, pos+2).toUpperCase() === "IN" && !/[A-Za-z0-9_]/.test(this.src[pos+2] || "")) {
        op = "IN";
        opKind = "in";
        opSpan = {start: pos, end: pos+2};
        pos += 2;
      } else {
        for (const cand of ops) {
          if (this.src.slice(pos, pos+cand.length) === cand) { op = cand; break; }
        }
        if (!op) return this.fail(pos, ["comparison operator or IN"]);
        opSpan = {start: pos, end: pos + op.length};
        pos += op.length;
      }

      pos = this.ws(pos);

      const parseLiteral = (p) => {
        let r = this.StringLiteral(p);
        if (!r.ok) r = this.NumberLiteral(p);
        if (!r.ok) r = this.NullLiteral(p);
        return r;
      };

      // RHS:
      // - for binary: literal (string/number/null)
      // - for IN: '(' literal (',' literal)* ')'
      let rightNode = null;

      if (opKind === "in") {
        if (this.src[pos] !== "(") return this.fail(pos, ["("]);
        const listStart = pos;
        pos++;
        pos = this.ws(pos);

        const values = [];
        const rFirst = parseLiteral(pos);
        if (!rFirst.ok) return this.fail(pos, ["literal (string/number/null)"]);
        values.push(rFirst.node);
        pos = this.ws(rFirst.pos);

        while (this.src[pos] === ",") {
          pos++;
          pos = this.ws(pos);
          const rN = parseLiteral(pos);
          if (!rN.ok) return this.fail(pos, ["literal (string/number/null)"]);
          values.push(rN.node);
          pos = this.ws(rN.pos);
        }

        if (this.src[pos] !== ")") return this.fail(pos, [")"]);
        pos++;
        rightNode = {type:"List", values, span:{start:listStart, end:pos}};
        pos = this.ws(pos);
      } else {
        const rRight = parseLiteral(pos);
        if (!rRight.ok) return this.fail(pos, ["literal (string/number/null)"]);
        rightNode = rRight.node;
        pos = this.ws(rRight.pos);
      }

      where = {
        left: rLeft.node,
        op,
        right: rightNode,
        span: {start: rLeft.node.span.start, end: rightNode.span.end}
      };
      // include operator span for pinpointing if needed
      where.opSpan = opSpan;
    }

    const obj = parts[0];
    const fieldPath = parts.slice(1).join(".");
    const node = {
      type: "Aggregate",
      object: obj,
      fieldPath,
      where,
      raw: this.src.slice(start, pos),
      span: {start, end: pos}
    };
    return this.ok(node, pos);
  }

  makeParseError(pos, expected) {
    const far = pos;
    const got = this.src[far] ?? "end of input";
    const exp = expected && expected.size ? Array.from(expected).slice(0,6).join(", ") : "valid token";
    return FormulaError(`Syntax error: expected ${exp} but found '${got}'`, {start: far, end: Math.min(far+1, this.len)}, "SYNTAX");
  }
}

/* ============================
   Function registry + typing
   ============================ */

const TYPES = Object.freeze({ NUMBER:"number", STRING:"string", BOOLEAN:"boolean", ANY:"any", NULL:"null" });

function typeName(t){ return t || TYPES.ANY; }

function isAssignable(actual, expected) {
  if (expected === TYPES.ANY) return true;
  if (expected === actual) return true;
  if (actual === TYPES.NULL && (expected === TYPES.ANY)) return true;
  return false;
}

const FUNCTIONS = {
  IF:   { min:3, max:3, args:[TYPES.BOOLEAN, TYPES.ANY, TYPES.ANY], returns:TYPES.ANY },
  EQ:   { min:2, max:2, args:[TYPES.ANY, TYPES.ANY], returns:TYPES.BOOLEAN },
  GT:   { min:2, max:2, args:[TYPES.NUMBER, TYPES.NUMBER], returns:TYPES.BOOLEAN },
  GE:   { min:2, max:2, args:[TYPES.NUMBER, TYPES.NUMBER], returns:TYPES.BOOLEAN },
  LT:   { min:2, max:2, args:[TYPES.NUMBER, TYPES.NUMBER], returns:TYPES.BOOLEAN },
  LE:   { min:2, max:2, args:[TYPES.NUMBER, TYPES.NUMBER], returns:TYPES.BOOLEAN },
  NUM:  { min:1, max:1, args:[TYPES.ANY], returns:TYPES.NUMBER },
  TEXT: { min:1, max:1, args:[TYPES.ANY], returns:TYPES.STRING },
  ROUND:{ min:2, max:3, args:[TYPES.NUMBER, TYPES.NUMBER, TYPES.STRING], returns:TYPES.NUMBER },
  ROUNDUP:{ min:2, max:2, args:[TYPES.NUMBER, TYPES.NUMBER], returns:TYPES.NUMBER },
  ROUNDDOWN:{ min:2, max:2, args:[TYPES.NUMBER, TYPES.NUMBER], returns:TYPES.NUMBER },
  NE:   { min:2, max:2, args:[TYPES.ANY, TYPES.ANY], returns:TYPES.BOOLEAN },
  MULT: { min:2, max:999, args:[TYPES.NUMBER], returns:TYPES.NUMBER },
  ADD:  { min:2, max:999, args:[TYPES.NUMBER], returns:TYPES.NUMBER },
  SUB:  { min:2, max:2, args:[TYPES.NUMBER, TYPES.NUMBER], returns:TYPES.NUMBER },
  DIV:  { min:2, max:2, args:[TYPES.NUMBER, TYPES.NUMBER], returns:TYPES.NUMBER },
  AND:  { min:2, max:999, args:[TYPES.BOOLEAN], returns:TYPES.BOOLEAN },
  OR:   { min:2, max:999, args:[TYPES.BOOLEAN], returns:TYPES.BOOLEAN },
  NOT:  { min:1, max:1, args:[TYPES.BOOLEAN], returns:TYPES.BOOLEAN },
  SUM:  { min:1, max:1, args:["aggregate"], returns:TYPES.NUMBER },
  COUNT:{ min:1, max:1, args:["aggregate"], returns:TYPES.NUMBER },
  AVG:  { min:1, max:1, args:["aggregate"], returns:TYPES.NUMBER },
  MIN:  { min:1, max:1, args:["aggregate"], returns:TYPES.NUMBER },
  MAX:  { min:1, max:1, args:["aggregate"], returns:TYPES.NUMBER },
};

function renderSupportedFunctionsTop() {
  const el = document.getElementById("supportedFns");
  if (!el) return;
  const names = Object.keys(FUNCTIONS).sort();
  el.textContent = Object.keys(FUNCTIONS).sort().join(", ");
}

function signatureFor(fn, sig) {
  if (!sig) return `${fn}(...)`;
  const argSpec = (() => {
    if (sig.args && sig.args[0] === "aggregate") return ["AggregateExpr"];
    if (sig.args && sig.args.length === 1 && sig.max > sig.min) return [`${sig.args[0]}...`];
    return (sig.args || []).map(a => a === "aggregate" ? "AggregateExpr" : a);
  })();
  const ar = (sig.min === sig.max)
    ? `${sig.min}`
    : `${sig.min}-${sig.max === 999 ? "N" : sig.max}`;
  return `${fn}(${argSpec.join(", ")}) -> ${sig.returns}   [arity ${ar}]`;
}

function renderSupportedFunctions() {
  const el = document.getElementById("fnlist");
  if (!el) return;
  const rows = Object.keys(FUNCTIONS)
    .sort()
    .map(fn => signatureFor(fn, FUNCTIONS[fn]));
  rows.push("");
  rows.push("Not yet supported (intentionally): LOOKUP, SUB, DIV, ADD, ROUND, AND/OR, etc.");
  el.textContent = Object.keys(FUNCTIONS).sort().join(", ");
}



function normalizeFnName(name){ return (name || "").toUpperCase(); }

/* ============================
   Validation + type inference
   ============================ */

function validateAndInfer(ast, src) {
  const issues = [];
  const expectations = new Map(); // inputKey -> expectedType

  function setExpectation(key, t, span) {
    const prev = expectations.get(key);
    if (!prev) { expectations.set(key, t); return; }
    if (prev === t) return;
    // number/string/boolean mismatch => keep ANY but record
    expectations.set(key, TYPES.ANY);
    issues.push({kind:"TYPE", message:`Conflicting type expectations for ${key}: ${prev} vs ${t}`, span});
  }

  function infer(node, expected=null) {
    if (!node) return TYPES.ANY;

    switch(node.type) {
      case "Number": return TYPES.NUMBER;
      case "String": return TYPES.STRING;
      case "Null":   return TYPES.NULL;

      case "MergeField": {
        if (expected && expected !== TYPES.ANY) setExpectation(node.path, expected, node.span);
        else setExpectation(node.path, TYPES.ANY, node.span);
        return expected || TYPES.ANY;
      }

      case "Aggregate": {
        // user must supply an aggregate numeric value
        const aggKey = aggregateKey(node);
        if (expected && expected !== TYPES.ANY) setExpectation(aggKey, expected, node.span);
        else setExpectation(aggKey, TYPES.NUMBER, node.span);
        return TYPES.NUMBER;
      }

      case "Call": {
        const fn = normalizeFnName(node.name);
        const sig = FUNCTIONS[fn];
        if (!sig) {
          issues.push({kind:"FUNC", message:`Unknown function '${node.name}'`, span: node.span});
          // still infer children to surface input fields
          node.args.forEach(a => infer(a));
          return TYPES.ANY;
        }

        // arity
        if (node.args.length < sig.min || node.args.length > sig.max) {
          issues.push({kind:"ARITY", message:`${fn} expects ${sig.min}${sig.max!==sig.min?`-${sig.max}`:""} arguments; got ${node.args.length}`, span: node.span});
        }

        // type-check args
        for (let i=0;i<node.args.length;i++) {
          const arg = node.args[i];
          let exp = TYPES.ANY;

          if (sig.args[0] === "aggregate") {
            exp = "aggregate";
          } else if (sig.args.length === 1 && sig.min !== 1) {
            exp = sig.args[0]; // varargs of single type (MULT)
          } else if (i < sig.args.length) {
            exp = sig.args[i];
          } else {
            exp = sig.args[sig.args.length-1] || TYPES.ANY;
          }

          if (exp === "aggregate") {
            if (arg.type !== "Aggregate") {
              issues.push({kind:"TYPE", message:`${fn} expects an aggregate expression like Object.Field WHERE ...`, span: arg.span});
              infer(arg); // still infer
            } else {
              // aggregates resolve as numbers
              setExpectation(aggregateKey(arg), TYPES.NUMBER, arg.span);

              // validate WHERE (limited)
              if (arg.where) {
                const op = arg.where.op;
                const allowed = ["=","!=",">",">=","<","<=","IN"];
                if (!allowed.includes(op)) {
                  issues.push({kind:"WHERE", message:`Unsupported WHERE operator '${op}'`, span: arg.where.opSpan || arg.where.span});
                }

                // Enforce Clariti convention: single quotes for string literals in WHERE filters
                const checkStringNode = (n) => {
                  if (n && n.type === "String" && n.quote !== "'") {
                    issues.push({kind:"WHERE", message:`String literals in WHERE filters must use single quotes (')`, span: n.span});
                  }
                };
                if (arg.where.right && arg.where.right.type === "List") {
                  for (const v of arg.where.right.values) checkStringNode(v);
                } else {
                  checkStringNode(arg.where.right);
                }
              }
            }
          } else {
            const actual = infer(arg, exp);
            if (!isAssignable(actual, exp) && actual !== TYPES.ANY) {
              issues.push({kind:"TYPE", message:`${fn} arg${i+1} expects ${typeName(exp)}; got ${typeName(actual)}`, span: arg.span});
            }
          }
        }
        return sig.returns;
      }

      default:
        return TYPES.ANY;
    }
  }


  function enforceScalarStringQuotes(node) {
    if (!node) return;
    switch(node.type) {
      case "String":
        if (node.quote === "'") {
          issues.push({kind:"STRING", message:`Scalar string literals must use double quotes (")`, span: node.span});
        }
        return;
      case "Aggregate":
        return;
      case "Call":
        for (const a of (node.args || [])) enforceScalarStringQuotes(a);
        return;
      default:
        return;
    }
  }

  const resultType = infer(ast);
  enforceScalarStringQuotes(ast);
  return {issues, expectations, resultType};
}

function aggregateKey(aggNode) {
  if (!aggNode || aggNode.type !== "Aggregate") return "";
  const whereStr = aggNode.where ? ` WHERE ${aggNode.where.left.parts.join(".")} ${aggNode.where.op} ${literalToString(aggNode.where.right)}` : "";
  return `${aggNode.object}.${aggNode.fieldPath}${whereStr}`;
}

function literalToString(node) {
  if (!node) return "";
  if (node.type === "String") { const q = node.quote || "\'"; return `${q}${node.value}${q}`; }
  if (node.type === "Number") return String(node.value);
  if (node.type === "Null") return "null";
  if (node.type === "List") return `(${node.values.map(literalToString).join(",")})`;
  return "?";
}

/* ============================
   Evaluation
   ============================ */

function evalAst(ast, env, src) {
  function missing(key, span) {
    throw FormulaError(`Missing value for ${key}`, span, "MISSING");
  }
  function toNumber(val, span, label="number") {
    if (val === null || val === undefined || val === "") throw FormulaError(`Missing ${label}`, span, "MISSING");
    const n = Number(val);
    if (!Number.isFinite(n)) throw FormulaError(`Expected ${label} but got '${val}'`, span, "TYPE");
    return n;
  }

  function evalNode(node) {
    switch(node.type) {
      case "Number": return node.value;
      case "String": return node.value;
      case "Null": return null;

      case "MergeField": {
        if (!(node.path in env)) missing(node.path, node.span);
        const v = env[node.path];
        return v === "" ? null : v;
      }

      case "Aggregate": {
        const key = aggregateKey(node);
        if (!(key in env)) missing(key, node.span);
        const v = env[key];
        return v === "" ? null : toNumber(v, node.span, "aggregate number");
      }

      case "Call": {
        const fn = normalizeFnName(node.name);
        if (!FUNCTIONS[fn]) throw FormulaError(`Unknown function '${node.name}'`, node.span, "FUNC");

        if (fn === "NE") {
          const a = evalNode(node.args[0]);
          const b = evalNode(node.args[1]);
          // Clariti-style: null is a value; compare by strict equality including null
          return (a !== b);
        }

        if (fn === "EQ") {
          const a = evalNode(node.args[0]);
          const b = evalNode(node.args[1]);
          return (a === b);
        }

        if (fn === "GT") {
          const a = toNumber(evalNode(node.args[0]), node.args[0].span, "GT arg1");
          const b = toNumber(evalNode(node.args[1]), node.args[1].span, "GT arg2");
          return a > b;
        }

        if (fn === "GE") {
          const a = toNumber(evalNode(node.args[0]), node.args[0].span, "GE arg1");
          const b = toNumber(evalNode(node.args[1]), node.args[1].span, "GE arg2");
          return a >= b;
        }

        if (fn === "LT") {
          const a = toNumber(evalNode(node.args[0]), node.args[0].span, "LT arg1");
          const b = toNumber(evalNode(node.args[1]), node.args[1].span, "LT arg2");
          return a < b;
        }

        if (fn === "LE") {
          const a = toNumber(evalNode(node.args[0]), node.args[0].span, "LE arg1");
          const b = toNumber(evalNode(node.args[1]), node.args[1].span, "LE arg2");
          return a <= b;
        }

        if (fn === "NUM") {
          const v = evalNode(node.args[0]);
          if (v === null) return null;
          const n = Number(v);
          if (!Number.isFinite(n)) throw FormulaError(`NUM cannot convert '${v}' to number`, node.args[0].span, "TYPE");
          return n;
        }

        if (fn === "TEXT") {
          const v = evalNode(node.args[0]);
          if (v === null) return "";
          return String(v);
        }

        function roundTo(n, digits) {
          const d = Math.trunc(digits);
          const factor = Math.pow(10, d);
          return n * factor;
        }

        function roundMode(n, digits, mode) {
          const d = Math.trunc(digits);
          const factor = Math.pow(10, d);
          const x = n * factor;
          const sign = x < 0 ? -1 : 1;
          const ax = Math.abs(x);
          const floor = Math.floor(ax);
          const frac = ax - floor;

          // HALF_EVEN (banker's): ties (.5) go to even
          if (mode === "HALF_EVEN") {
            if (Math.abs(frac - 0.5) < 1e-12) {
              const even = (floor % 2 === 0) ? floor : floor + 1;
              return sign * even / factor;
            }
            return sign * Math.round(ax) / factor;
          }

          // HALF_UP: ties go away from zero
          if (mode === "HALF_UP") {
            const r = (frac > 0.5 || Math.abs(frac - 0.5) < 1e-12) ? (floor + 1) : floor;
            return sign * r / factor;
          }

          // HALF_DOWN: ties go toward zero
          if (mode === "HALF_DOWN") {
            const r = (frac > 0.5) ? (floor + 1) : floor;
            return sign * r / factor;
          }

          // UP: away from zero
          if (mode === "UP") return sign * Math.ceil(ax) / factor;

          // DOWN: toward zero
          if (mode === "DOWN") return sign * Math.floor(ax) / factor;

          // default: HALF_UP
          const r = (frac > 0.5 || Math.abs(frac - 0.5) < 1e-12) ? (floor + 1) : floor;
          return sign * r / factor;
        }

        if (fn === "ROUND") {
          const n = toNumber(evalNode(node.args[0]), node.args[0].span, "ROUND number");
          const digits = toNumber(evalNode(node.args[1]), node.args[1].span, "ROUND num_digits");
          const mode = (node.args.length >= 3) ? String(evalNode(node.args[2])) : "HALF_UP";
          return roundMode(n, digits, String(mode).toUpperCase());
        }

        if (fn === "ROUNDUP") {
          const n = toNumber(evalNode(node.args[0]), node.args[0].span, "ROUNDUP number");
          const digits = toNumber(evalNode(node.args[1]), node.args[1].span, "ROUNDUP num_digits");
          const d = Math.trunc(digits);
          const factor = Math.pow(10, d);
          const x = n * factor;
          const r = (x < 0) ? Math.floor(x) : Math.ceil(x);
          return r / factor;
        }

        if (fn === "ROUNDDOWN") {
          const n = toNumber(evalNode(node.args[0]), node.args[0].span, "ROUNDDOWN number");
          const digits = toNumber(evalNode(node.args[1]), node.args[1].span, "ROUNDDOWN num_digits");
          const d = Math.trunc(digits);
          const factor = Math.pow(10, d);
          const x = n * factor;
          const r = (x < 0) ? Math.ceil(x) : Math.floor(x);
          return r / factor;
        }

        if (fn === "IF") {
          const cond = evalNode(node.args[0]);
          if (typeof cond !== "boolean") throw FormulaError(`IF condition must be boolean`, node.args[0].span, "TYPE");
          return cond ? evalNode(node.args[1]) : evalNode(node.args[2]);
        }


        if (fn === "AND") {
          let out = true;
          for (let i=0;i<node.args.length;i++) {
            const v = evalNode(node.args[i]);
            if (typeof v !== "boolean") throw FormulaError(`AND arg${i+1} must be boolean`, node.args[i].span, "TYPE");
            out = out && v;
            if (!out) break;
          }
          return out;
        }

        if (fn === "OR") {
          let out = false;
          for (let i=0;i<node.args.length;i++) {
            const v = evalNode(node.args[i]);
            if (typeof v !== "boolean") throw FormulaError(`OR arg${i+1} must be boolean`, node.args[i].span, "TYPE");
            out = out || v;
            if (out) break;
          }
          return out;
        }

        if (fn === "NOT") {
          const v = evalNode(node.args[0]);
          if (typeof v !== "boolean") throw FormulaError(`NOT arg1 must be boolean`, node.args[0].span, "TYPE");
          return !v;
        }

        if (fn === "ADD") {
          let sum = 0;
          for (let i=0;i<node.args.length;i++) {
            const v = evalNode(node.args[i]);
            const n = toNumber(v, node.args[i].span, `ADD arg${i+1}`);
            sum += n;
          }
          return sum;
        }

        if (fn === "SUB") {
          const a = toNumber(evalNode(node.args[0]), node.args[0].span, "SUB arg1");
          const b = toNumber(evalNode(node.args[1]), node.args[1].span, "SUB arg2");
          return a - b;
        }

        if (fn === "DIV") {
          const a = toNumber(evalNode(node.args[0]), node.args[0].span, "DIV arg1");
          const b = toNumber(evalNode(node.args[1]), node.args[1].span, "DIV arg2");
          if (b === 0) throw FormulaError(`Division by zero`, node.args[1].span, "MATH");
          return a / b;
        }

        if (fn === "MULT") {
          let prod = 1;
          for (let i=0;i<node.args.length;i++) {
            const v = evalNode(node.args[i]);
            const n = toNumber(v, node.args[i].span, `MULT arg${i+1}`);
            prod *= n;
          }
          return prod;
        }

        if (["SUM","COUNT","AVG","MIN","MAX"].includes(fn)) {
          if (node.args.length !== 1) throw FormulaError(`${fn} expects 1 argument`, node.span, "ARITY");
          if (node.args[0].type !== "Aggregate") throw FormulaError(`${fn} expects an aggregate expression`, node.args[0].span, "TYPE");
          // In this prototype, aggregate value is supplied by user (already numeric)
          return evalNode(node.args[0]);
        }

        throw FormulaError(`Function '${fn}' not implemented`, node.span, "FUNC");
      }

      default:
        throw FormulaError(`Unsupported node type '${node.type}'`, node.span, "ERROR");
    }
  }

  const out = evalNode(ast);
  // Enforce non-negative fee amount (your requirement)
  if (typeof out === "number" && out < 0) throw FormulaError(`Calculated fee is negative; this is not allowed`, ast.span, "FEE");
  return out;
}

/* ============================
   UI glue
   ============================ */

const elFormula = document.getElementById("formula");
const elParseStatus = document.getElementById("parseStatus");
const elDiag = document.getElementById("diagnostics");
const elDiagStatus = document.getElementById("diagStatus");
const elInputs = document.getElementById("inputs");
const elOut = document.getElementById("output");
const elInputsCount = document.getElementById("inputsCount");
const elSelf = document.getElementById("selftests");

let lastAst = null;
let lastExpectations = null;

function setStatus(text, ok=null) {
  elParseStatus.textContent = text;
  elParseStatus.style.borderColor = ok === null ? "var(--line)" : (ok ? "rgba(43,213,118,.6)" : "rgba(255,107,107,.6)");
  elParseStatus.style.color = ok === null ? "var(--muted)" : (ok ? "var(--ok)" : "var(--bad)");
}

function renderDiagnostics(src, errOrIssues) {
  if (!errOrIssues) { elDiag.textContent = ""; return; }

  if (errOrIssues instanceof Error) {
    const e = errOrIssues;
    const loc = formatSpan(src, e.span);
    const head = `[${e.kind || "ERROR"}] ${e.message}${loc}`;
    const caret = caretSnippet(src, e.span);
    elDiag.innerHTML = `${escapeHtml(head)}\n\n${escapeHtml(caret)}`;
    return;
  }

  // issues array
  const lines = [];
  for (const it of errOrIssues) {
    const loc = formatSpan(src, it.span);
    lines.push(`[${it.kind}] ${it.message}${loc}`);
    lines.push(caretSnippet(src, it.span));
    lines.push("");
  }
  elDiag.textContent = lines.join("\n");
}

function escapeHtml(s){ return (s||"").replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;"); }

function buildInputs(expectations) {
  elInputs.innerHTML = "";
  const entries = Array.from(expectations.entries())
    // Defensive: never render function names as "inputs" even if they appear due to bad inference
    .filter(([k,_t]) => !(k in FUNCTIONS));
  entries.sort((a,b)=>a[0].localeCompare(b[0]));
  elInputsCount.textContent = entries.length ? String(entries.length) : "0";

  for (const [key, t] of entries) {
    const wrap = document.createElement("div");
    wrap.className = "field";
    const left = document.createElement("div");
    const label = document.createElement("label");
    label.className = "mono";
    label.textContent = key;
    const meta = document.createElement("div");
    meta.className = "meta mono";
    meta.textContent = `expected: ${t}`;

    left.appendChild(label);
    left.appendChild(meta);

    const input = document.createElement("input");
    input.dataset.key = key;

    if (t === TYPES.NUMBER) input.type = "number";
    else if (t === TYPES.BOOLEAN) input.type = "checkbox";
    else input.type = "text";

    input.placeholder = (t === TYPES.NUMBER) ? "e.g., 123.45" : (t === TYPES.BOOLEAN ? "" : "text or leave blank for null");

    wrap.appendChild(left);
    wrap.appendChild(input);
    elInputs.appendChild(wrap);
  }
}

function readEnvFromInputs() {
  const env = {};
  const nodes = elInputs.querySelectorAll("input");
  nodes.forEach(inp => {
    const key = inp.dataset.key;
    if (inp.type === "checkbox") env[key] = !!inp.checked;
    else env[key] = inp.value;
  });
  return env;
}

function analyze() {
  const src = elFormula.value || "";
  elOut.textContent = "";
  lastAst = null;
  lastExpectations = null;

  try {
    const ast = new Parser(src).parse();
    const {issues, expectations, resultType} = validateAndInfer(ast, src);

    lastAst = ast;
    lastExpectations = expectations;

    buildInputs(expectations);

    if (issues.length) {
      setStatus("Parsed (with issues)", false);
      elDiagStatus.textContent = `Issues: ${issues.length}`;
      renderDiagnostics(src, issues);
    } else {
      setStatus("Parsed OK", true);
      elDiagStatus.textContent = `OK (result type: ${resultType})`;
      elDiag.textContent = "No issues detected.";
    }
  } catch (e) {
    setStatus("Parse failed", false);
    elDiagStatus.textContent = "Syntax error";
    renderDiagnostics(src, e);
    elInputs.innerHTML = "";
    elInputsCount.textContent = "—";
  }
}

function calculate() {
  const src = elFormula.value || "";
  if (!lastAst || !lastExpectations) analyze();
  if (!lastAst) return;

  // If there are validation issues, block calculation (practical default)
  const {issues} = validateAndInfer(lastAst, src);
  if (issues.length) {
    elOut.innerHTML = `<span class="bad">Blocked: fix validation issues first.</span>`;
    renderDiagnostics(src, issues);
    return;
  }

  try {
    const env = readEnvFromInputs();
    const val = evalAst(lastAst, env, src);
    elOut.innerHTML = `<span class="ok">Result:</span> ${escapeHtml(String(val))}`;
    setStatus("Evaluated OK", true);
  } catch (e) {
    setStatus("Evaluation failed", false);
    elOut.innerHTML = `<span class="bad">Error:</span> ${escapeHtml(e.message)}${escapeHtml(formatSpan(src, e.span))}`;
    renderDiagnostics(src, e);
  }
}

function selfTests() {
  const cases = [
    {name:"MULT(3,4,5)", formula:"MULT(3,4,5)", env:{}, expect:60},
    {name:"ADD(1,2,3.5)", formula:"ADD(1,2,3.5)", env:{}, expect:6.5},
    {name:"SUB(10,4)", formula:"SUB(10,4)", env:{}, expect:6},
    {name:"DIV(10,2)", formula:"DIV(10,2)", env:{}, expect:5},
    {name:"DIV by zero", formula:"DIV(10,0)", env:{}, expectError:true},
    {name:"EQ(TEXT('Hello'), TEXT('World')) => false", formula:"EQ(TEXT('Hello'), TEXT('World'))", env:{}, expect:false},
    {name:"GE(100,100) => true", formula:"GE(100,100)", env:{}, expect:true},
    {name:"GT(100,100) => false", formula:"GT(100,100)", env:{}, expect:false},
    {name:"LE(5,5) => true", formula:"LE(5,5)", env:{}, expect:true},
    {name:"LT(3,4) => true", formula:"LT(3,4)", env:{}, expect:true},
    {name:"ROUND(225.49823, 2, 'HALF_EVEN') => 225.5", formula:"ROUND(225.49823, 2, 'HALF_EVEN')", env:{}, expect:225.5},
    {name:"ROUNDUP(1.5,0) => 2", formula:"ROUNDUP(1.5,0)", env:{}, expect:2},
    {name:"ROUNDDOWN(1.5,0) => 1", formula:"ROUNDDOWN(1.5,0)", env:{}, expect:1},
    {name:"NE(null,null) => false", formula:"NE(null, null)", env:{}, expect:false},
    {name:"AND(true, NOT(false)) => true", formula:"AND(true, NOT(false))", env:{}, expect:true},
    {name:"OR(false, NE(1,1), true) => true", formula:"OR(false, NE(1,1), true)", env:{}, expect:true},
    {name:"IF sample with x null => 0", formula: SAMPLE_FORMULA, env:{
      "{!MUSW__Application2__c.LACPS_Green_Building_Tier__c}":"",
      "MUSW__Fee__c.MUSW__Amount__c WHERE MUSW__Fee_Template__r.MUSW__Processing_Order__c = '0'":"1000"
    }, expect:0},
    {name:"IF sample with x set and SUM=1000 => 100", formula: SAMPLE_FORMULA, env:{
      "{!MUSW__Application2__c.LACPS_Green_Building_Tier__c}":"Tier1",
      "MUSW__Fee__c.MUSW__Amount__c WHERE MUSW__Fee_Template__r.MUSW__Processing_Order__c = '0'":"1000"
    }, expect:100},
    {name:"Bad syntax missing ')'", formula:"MULT(1,2", env:{}, expectError:true},
    {name:"SUM with IN list parses", formula:"SUM(A.B WHERE C.D IN (\'0\',\'1\'))", env:{}, expectError:true},
    {name:"SUM requires aggregate expression", formula:"SUM(1)", env:{}, expectError:true},
    {name:"Unsupported WHERE operator ==", formula:"SUM(A.B WHERE C.D == '0')", env:{"A.B":"1"}, expectError:true},
    {name:"Unsupported function LOOKUP stops immediately", formula:"LOOKUP('x',1)", env:{}, expectError:true},
  ];

  const lines = [];
  for (const tc of cases) {
    try {
      const src = tc.formula;
      const ast = new Parser(src).parse();
      const {issues, expectations} = validateAndInfer(ast, src);
      if (issues.length) {
        if (tc.expectError) { lines.push(`[PASS] ${tc.name} — blocked by validation (${issues[0].kind})`); continue; }
        lines.push(`[FAIL] ${tc.name} — validation issues: ${issues.map(x=>x.kind).join(",")}`);
        continue;
      }
      // build env; auto-fill any expected values not provided with 1 for numbers
      const env = Object.assign({}, tc.env);
      for (const [k,t] of expectations.entries()) {
        if (!(k in env)) env[k] = (t===TYPES.NUMBER) ? "1" : "";
      }
      const val = evalAst(ast, env, src);
      if (tc.expectError) lines.push(`[FAIL] ${tc.name} — expected error, got ${val}`);
      else if (Object.is(val, tc.expect)) lines.push(`[PASS] ${tc.name}`);
      else lines.push(`[FAIL] ${tc.name} — expected ${tc.expect}, got ${val}`);
    } catch (e) {
      if (tc.expectError) lines.push(`[PASS] ${tc.name} — error: ${e.kind||"ERROR"}${formatSpan(tc.formula, e.span)}`);
      else lines.push(`[FAIL] ${tc.name} — unexpected error: ${e.message}${formatSpan(tc.formula, e.span)}`);
    }
  }
  elSelf.textContent = lines.join("\n");
}

/* ============================
   Sample formula
   ============================ */

const SAMPLE_FORMULA = `IF
\t(NE
\t\t({!MUSW__Application2__c.LACPS_Green_Building_Tier__c}
\t\t,null)
\t\t\t,MULT
\t\t\t\t(0.1
\t\t\t\t\t,SUM
\t\t\t\t\t\t(MUSW__Fee__c.MUSW__Amount__c WHERE MUSW__Fee_Template__r.MUSW__Processing_Order__c = '0')
\t\t\t\t)
\t,0)`;

document.getElementById("btnLoad").addEventListener("click", () => {
  elFormula.value = SAMPLE_FORMULA;
  setStatus("Loaded sample", null);
  elDiag.textContent = "";
  elOut.textContent = "";
  elSelf.textContent = "";
});

document.getElementById("btnAnalyze").addEventListener("click", analyze);
document.getElementById("btnCalc").addEventListener("click", calculate);
document.getElementById("btnSelfTest").addEventListener("click", selfTests);

// Convenience: analyze as user types (debounced)
let tmr = null;
elFormula.addEventListener("input", () => {
  clearTimeout(tmr);
  tmr = setTimeout(analyze, 300);
});

renderSupportedFunctionsTop();
setStatus("Idle", null);
</script>
</body>
</html>
